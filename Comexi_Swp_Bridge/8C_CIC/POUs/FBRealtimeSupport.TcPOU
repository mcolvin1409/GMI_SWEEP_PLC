<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.10">
  <POU Name="FBRealtimeSupport" Id="{6abeff8e-f12a-423c-ba2e-ae8ec777e99d}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FBRealtimeSupport
///SDOC/////////////////////////////////////////////////////////////////////////
//
//  FBRealtimeSupport.TcPOU      - Function Block - Real-time diagnostic data with analog data - AVT PLC 
//						Version 1
//  Author:         Mark Colvin                         Date: Sept 5, 2018
//
//	Beckhoff TC3 Structured Text for CX8190 PLC
//
//	includes features:
//		10 inker enables
///////////////////////////////////////////////////////////////////////SDOCEND//
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	// === LOCAL DATA === NOT saved over power cycles
	Index		:WORD;	//temp fountain index 
	wCycleCount	:WORD;	//cycle count for ON time for inker/water adjustments
	nActualScaled: INT;
	iActual: INT;
	w_output_incr	:INT;
END_VAR
VAR CONSTANT
	FTN1		:WORD:= 0;	//constants for fountain indexes fro IO arrays in TBs
	FTN2		:WORD:= 1;
	FTN3		:WORD:= 2;
	FTN4		:WORD:= 3;
	FTN5		:WORD:= 4;
	FTN6		:WORD:= 5;
	FTN7		:WORD:= 6;
	FTN8		:WORD:= 7;
	FTN9		:WORD:= 8;
	FTN10	:WORD:= 9;
	wMotorTimeOn :WORD:=500;  //wMotorTimeOn, how long the output is ON for ONE motor adjustment(+ or -), 1000 = 1second
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
	 CASE GVL.mb_Output_Registers[GVL.REALTIME_DATA_SELECTION] OF		//this is user selection of fountain control to inspect/modify
	 0:	//do nothing here
	 
	 // Inker analog inputs and outputs
	 1:	Index := FTN1;		//assign temp index
		CASE GVL.mb_Output_Registers[GVL.INKERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN1 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN1] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN1] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN1] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN1] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN1 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN1] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN1] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN1] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN1] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkInput[FTN1]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF INT_TO_WORD(GVL_IO.InkInput[FTN1]) < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN1 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN1] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN1] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN1] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN1] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter	
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN10 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN1]) - GVL.w_InkInputIntMin[FTN10]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN10] - GVL.w_InkInputIntMin[FTN10]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF INT_TO_WORD(GVL_IO.InkInput[FTN1]) > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN1 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN1] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN1] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN1] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN1] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN1 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN1]) - GVL.w_InkInputIntMin[FTN1]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN1] - GVL.w_InkInputIntMin[FTN1]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkSweepOut[FTN1]);
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF (GVL_IO.InkSweepOut[FTN1]) < (w_output_incr *100) THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN1 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN1] := (GVL_IO.InkSweepOut[FTN1]) + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF (GVL_IO.InkSweepOut[FTN1]) > w_output_incr THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN1 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN1] := (GVL_IO.InkSweepOut[FTN1]) - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:

		END_CASE
	 2:	Index := FTN2;		//assign temp index
		CASE GVL.mb_Output_Registers[GVL.INKERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN2 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN2] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN2] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN2] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN2] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN2 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN2] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN2] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN2] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN2] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkInput[FTN2]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF INT_TO_WORD(GVL_IO.InkInput[FTN2]) < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN2 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN2] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN2] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN2] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN2] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter	
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN2 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN2]) - GVL.w_InkInputIntMin[FTN2]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN2] - GVL.w_InkInputIntMin[FTN2]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF INT_TO_WORD(GVL_IO.InkInput[FTN2]) > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN2 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN2] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN2] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN2] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN2] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN2 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN2]) - GVL.w_InkInputIntMin[FTN2]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN2] - GVL.w_InkInputIntMin[FTN2]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkSweepOut[FTN2]);
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.InkSweepOut[FTN2] < (w_output_incr *100) THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN2 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN2] := GVL_IO.InkSweepOut[FTN2] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.InkSweepOut[FTN2] > w_output_incr THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN2 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN2] := GVL_IO.InkSweepOut[FTN2] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 3:	Index := FTN3;		//assign temp index
		CASE GVL.mb_Output_Registers[GVL.INKERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN3 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN3] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN3] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN3] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN3] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN3 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN3] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN3] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN3] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN3] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkInput[FTN3]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF INT_TO_WORD(GVL_IO.InkInput[FTN3]) < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN3 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN3] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN3] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN3] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN3] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter	
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN3 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN3]) - GVL.w_InkInputIntMin[FTN3]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN3] - GVL.w_InkInputIntMin[FTN3]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF INT_TO_WORD(GVL_IO.InkInput[FTN3]) > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN3 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN3] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN3] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN3] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN3] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN3 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN3]) - GVL.w_InkInputIntMin[FTN3]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN3] - GVL.w_InkInputIntMin[FTN3]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkSweepOut[FTN3]);
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.InkSweepOut[FTN3] < (w_output_incr *100) THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN3 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN3] := GVL_IO.InkSweepOut[FTN3] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.InkSweepOut[FTN3] > w_output_incr THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN3 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN3] := GVL_IO.InkSweepOut[FTN3] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)		
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 4:	Index := FTN4;		//assign temp index
		CASE GVL.mb_Output_Registers[GVL.INKERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN4 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN4] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN4] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN4] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN4] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN4 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN4] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN4] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN4] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN4] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkInput[FTN4]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF INT_TO_WORD(GVL_IO.InkInput[FTN4]) < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN4 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN4] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN4] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN4] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN4] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter	
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN4 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN4]) - GVL.w_InkInputIntMin[FTN4]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN4] - GVL.w_InkInputIntMin[FTN4]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF INT_TO_WORD(GVL_IO.InkInput[FTN4]) > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN4 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN4] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN4] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN4] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN4] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN4 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN4]) - GVL.w_InkInputIntMin[FTN4]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN4] - GVL.w_InkInputIntMin[FTN4]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkSweepOut[FTN4]);
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.InkSweepOut[FTN4] < (w_output_incr *100) THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN4 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN4] := GVL_IO.InkSweepOut[FTN4] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.InkSweepOut[FTN4] > w_output_incr THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN4 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN4] := GVL_IO.InkSweepOut[FTN4] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 5:	Index := FTN5;		//assign temp index
		CASE GVL.mb_Output_Registers[GVL.INKERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN5 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN5] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN5] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN5] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN5] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN5 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN5] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN5] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN5] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN5] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkInput[FTN5]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF INT_TO_WORD(GVL_IO.InkInput[FTN5]) < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN5 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN5] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN5] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN5] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN5] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter	
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN5 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN5]) - GVL.w_InkInputIntMin[FTN5]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN5] - GVL.w_InkInputIntMin[FTN5]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF INT_TO_WORD(GVL_IO.InkInput[FTN5]) > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN5 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN5] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN5] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN5] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN5] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN5 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN5]) - GVL.w_InkInputIntMin[FTN5]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN5] - GVL.w_InkInputIntMin[FTN5]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkSweepOut[FTN5]);
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.InkSweepOut[FTN5] < (w_output_incr *100) THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN5 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN5] := GVL_IO.InkSweepOut[FTN5] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.InkSweepOut[FTN5] > w_output_incr THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN5 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN5] := GVL_IO.InkSweepOut[FTN5] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 6:	Index := FTN6;		//assign temp index
		CASE GVL.mb_Output_Registers[GVL.INKERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN6 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN6] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN6] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN6] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN6] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN6 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN6] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN6] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN6] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN6] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkInput[FTN6]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF INT_TO_WORD(GVL_IO.InkInput[FTN6]) < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN6 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN6] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN6] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN6] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN6] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter	
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN6 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN6]) - GVL.w_InkInputIntMin[FTN6]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN6] - GVL.w_InkInputIntMin[FTN6]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF INT_TO_WORD(GVL_IO.InkInput[FTN6]) > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN6 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN6] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN6] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN6] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN6] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN6 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN6]) - GVL.w_InkInputIntMin[FTN6]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN6] - GVL.w_InkInputIntMin[FTN6]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkSweepOut[FTN6]);
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.InkSweepOut[FTN6] < (w_output_incr *100) THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN6 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN6] := GVL_IO.InkSweepOut[FTN6] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.InkSweepOut[FTN6] > w_output_incr THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN6 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN6] := GVL_IO.InkSweepOut[FTN6] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 7:	Index := FTN7;		//assign temp index
		CASE GVL.mb_Output_Registers[GVL.INKERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN7 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN7] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN7] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN7] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN7] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN7 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN7] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN7] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN7] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN7] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkInput[FTN7]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF INT_TO_WORD(GVL_IO.InkInput[FTN7]) < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN7 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN7] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN7] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN7] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN7] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter	
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN7 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN7]) - GVL.w_InkInputIntMin[FTN7]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN7] - GVL.w_InkInputIntMin[FTN7]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF INT_TO_WORD(GVL_IO.InkInput[FTN7]) > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN7 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN7] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN7] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN7] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN7] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN7 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN7]) - GVL.w_InkInputIntMin[FTN7]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN7] - GVL.w_InkInputIntMin[FTN7]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkSweepOut[FTN7]);
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.InkSweepOut[FTN7] < (w_output_incr *100) THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN7 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN7] := GVL_IO.InkSweepOut[FTN7] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.InkSweepOut[FTN7] > w_output_incr THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN7 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN7] := GVL_IO.InkSweepOut[FTN7] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 8:	Index := FTN8;		//assign temp index
		CASE GVL.mb_Output_Registers[GVL.INKERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN8 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN8] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN8] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN8] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN8] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN8 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN8] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN8] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN8] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN8] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkInput[FTN8]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF INT_TO_WORD(GVL_IO.InkInput[FTN8]) < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN8 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN8] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN8] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN8] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN8] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter	
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN8 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN8]) - GVL.w_InkInputIntMin[FTN8]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN8] - GVL.w_InkInputIntMin[FTN8]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF INT_TO_WORD(GVL_IO.InkInput[FTN8]) > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN8 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN8] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN8] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN8] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN8] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN8 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN8]) - GVL.w_InkInputIntMin[FTN8]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN8] - GVL.w_InkInputIntMin[FTN8]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkSweepOut[FTN8]);
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.InkSweepOut[FTN8] < (w_output_incr *100) THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN8 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN8] := GVL_IO.InkSweepOut[FTN8] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.InkSweepOut[FTN8] > w_output_incr THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN8 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN8] := GVL_IO.InkSweepOut[FTN8] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 9:	Index := FTN9;		//assign temp index
		CASE GVL.mb_Output_Registers[GVL.INKERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN9 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN9] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN9] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN9] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN9] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN9 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN9] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN9] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN9] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN9] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkInput[FTN9]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF INT_TO_WORD(GVL_IO.InkInput[FTN9]) < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN9 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN9] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN9] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN9] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN9] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter	
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN9 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN9]) - GVL.w_InkInputIntMin[FTN9]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN9] - GVL.w_InkInputIntMin[FTN9]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF INT_TO_WORD(GVL_IO.InkInput[FTN9]) > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN9 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN9] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN9] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN9] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN9] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN9 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN9]) - GVL.w_InkInputIntMin[FTN9]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN9] - GVL.w_InkInputIntMin[FTN9]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkSweepOut[FTN9]);
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.InkSweepOut[FTN9] < (w_output_incr *100) THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN9 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN9] := GVL_IO.InkSweepOut[FTN9] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.InkSweepOut[FTN9] > w_output_incr THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN9 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN9] := GVL_IO.InkSweepOut[FTN9] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 10:Index := FTN10;		//assign temp index
		CASE GVL.mb_Output_Registers[GVL.INKERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN10 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN10] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN10] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN10] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN10] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN10 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN10] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN10] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN10] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN10] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkInput[FTN10]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF INT_TO_WORD(GVL_IO.InkInput[FTN10]) < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN10 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN10] := TRUE;				// turn on the advance output
					GVL_IO.InkMotorRvs[FTN10] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN10] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN10] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter	
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN10 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN10]) - GVL.w_InkInputIntMin[FTN10]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN10] - GVL.w_InkInputIntMin[FTN10]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF INT_TO_WORD(GVL_IO.InkInput[FTN10]) > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN10 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkMotorFwd[FTN10] := FALSE;				// turn on the reverse output
					GVL_IO.InkMotorRvs[FTN10] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.InkMotorFwd[FTN10] := FALSE;		//turn off outputs
						GVL_IO.InkMotorRvs[FTN10] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN10 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN10]) - GVL.w_InkInputIntMin[FTN10]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN10] - GVL.w_InkInputIntMin[FTN10]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.InkSweepOut[FTN10]);
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.InkSweepOut[FTN10] < (w_output_incr *100) THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN10 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN10] := GVL_IO.InkSweepOut[FTN10] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.InkSweepOut[FTN10] > w_output_incr THEN
					GVL.mb_Output_Coils[GVL.InkSweepRUN +(FTN10 * GVL.BOOLRUNTIMEGROUPSIZE)] := 	TRUE; //next RUN will force to console target
					GVL_IO.InkSweepOut[FTN10] := GVL_IO.InkSweepOut[FTN10] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE

	// Water analog inputs and outputs

  	 11:CASE GVL.mb_Output_Registers[GVL.WATERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN1] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN1] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN1] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN1] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN1] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN1] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN1] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN1] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterInput[FTN1]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF GVL_IO.WaterInput[FTN1] < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN1] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN1] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN1] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN1] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN1 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN1]) - GVL.w_InkInputIntMin[FTN1]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN1] - GVL.w_InkInputIntMin[FTN1]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterInput[FTN1] > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN1] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN1] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN1] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN1] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN1 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN1]) - GVL.w_InkInputIntMin[FTN1]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN1] - GVL.w_InkInputIntMin[FTN1]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterSweepOut[FTN1]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.WaterSweepOut[FTN1] < (w_output_incr * 10) THEN
					GVL_IO.WaterSweepOut[FTN1] := GVL_IO.WaterSweepOut[FTN1] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterSweepOut[FTN1] > w_output_incr THEN
					GVL_IO.WaterSweepOut[FTN1] := GVL_IO.WaterSweepOut[FTN1] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 12:CASE GVL.mb_Output_Registers[GVL.WATERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN2] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN2] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN2] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN2] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN2] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN2] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN2] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN2] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterInput[FTN2]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF GVL_IO.WaterInput[FTN2] < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN2] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN2] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN2] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN2] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN2 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN2]) - GVL.w_InkInputIntMin[FTN2]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN2] - GVL.w_InkInputIntMin[FTN2]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterInput[FTN2] > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN2] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN2] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN2] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN2] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN2 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN2]) - GVL.w_InkInputIntMin[FTN2]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN2] - GVL.w_InkInputIntMin[FTN2]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterSweepOut[FTN2]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.WaterSweepOut[FTN2] < (w_output_incr * 10) THEN
					GVL_IO.WaterSweepOut[FTN2] := GVL_IO.WaterSweepOut[FTN2] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterSweepOut[FTN2] > w_output_incr THEN
					GVL_IO.WaterSweepOut[FTN2] := GVL_IO.WaterSweepOut[FTN2] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 13:CASE GVL.mb_Output_Registers[GVL.WATERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN3] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN3] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN3] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN3] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN3] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN3] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN3] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN3] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterInput[FTN3]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF GVL_IO.WaterInput[FTN3] < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN3] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN3] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN3] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN3] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN3 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN3]) - GVL.w_InkInputIntMin[FTN3]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN3] - GVL.w_InkInputIntMin[FTN3]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterInput[FTN3] > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN3] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN3] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN3] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN3] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN3 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN3]) - GVL.w_InkInputIntMin[FTN3]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN3] - GVL.w_InkInputIntMin[FTN3]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterSweepOut[FTN3]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.WaterSweepOut[FTN3] < (w_output_incr * 10) THEN
					GVL_IO.WaterSweepOut[FTN3] := GVL_IO.WaterSweepOut[FTN3] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterSweepOut[FTN3] > w_output_incr THEN
					GVL_IO.WaterSweepOut[FTN3] := GVL_IO.WaterSweepOut[FTN3] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 14:CASE GVL.mb_Output_Registers[GVL.WATERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN4] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN4] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN4] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN4] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN4] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN4] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN4] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN4] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterInput[FTN4]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF GVL_IO.WaterInput[FTN4] < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN4] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN4] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN4] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN4] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN4 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN4]) - GVL.w_InkInputIntMin[FTN4]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN4] - GVL.w_InkInputIntMin[FTN4]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterInput[FTN4] > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN4] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN4] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN4] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN4] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN4 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN4]) - GVL.w_InkInputIntMin[FTN4]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN4] - GVL.w_InkInputIntMin[FTN4]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterSweepOut[FTN4]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.WaterSweepOut[FTN4] < (w_output_incr * 10) THEN
					GVL_IO.WaterSweepOut[FTN4] := GVL_IO.WaterSweepOut[FTN4] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterSweepOut[FTN4] > w_output_incr THEN
					GVL_IO.WaterSweepOut[FTN4] := GVL_IO.WaterSweepOut[FTN4] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 15:CASE GVL.mb_Output_Registers[GVL.WATERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN5] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN5] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN5] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN5] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN5] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN5] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN5] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN5] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterInput[FTN5]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF GVL_IO.WaterInput[FTN5] < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN5] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN5] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN5] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN5] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN5 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN5]) - GVL.w_InkInputIntMin[FTN5]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN5] - GVL.w_InkInputIntMin[FTN5]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterInput[FTN5] > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN5] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN5] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN5] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN5] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN5 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN5]) - GVL.w_InkInputIntMin[FTN5]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN5] - GVL.w_InkInputIntMin[FTN5]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterSweepOut[FTN5]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.WaterSweepOut[FTN5] < (w_output_incr * 10) THEN
					GVL_IO.WaterSweepOut[FTN5] := GVL_IO.WaterSweepOut[FTN5] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterSweepOut[FTN5] > w_output_incr THEN
					GVL_IO.WaterSweepOut[FTN5] := GVL_IO.WaterSweepOut[FTN5] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 16:	CASE GVL.mb_Output_Registers[GVL.WATERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN6] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN6] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN6] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN6] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN6] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN6] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN6] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN6] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterInput[FTN6]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF GVL_IO.WaterInput[FTN6] < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN6] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN6] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN6] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN6] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN6 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN6]) - GVL.w_InkInputIntMin[FTN6]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN6] - GVL.w_InkInputIntMin[FTN6]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterInput[FTN6] > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN6] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN6] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN6] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN6] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN6 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN6]) - GVL.w_InkInputIntMin[FTN6]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN6] - GVL.w_InkInputIntMin[FTN6]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterSweepOut[FTN6]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.WaterSweepOut[FTN6] < (w_output_incr * 10) THEN
					GVL_IO.WaterSweepOut[FTN6] := GVL_IO.WaterSweepOut[FTN6] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterSweepOut[FTN6] > w_output_incr THEN
					GVL_IO.WaterSweepOut[FTN6] := GVL_IO.WaterSweepOut[FTN6] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 17:CASE GVL.mb_Output_Registers[GVL.WATERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN7] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN7] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN7] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN7] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN7] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN7] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN7] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN7] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterInput[FTN7]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF GVL_IO.WaterInput[FTN7] < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN7] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN7] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN7] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN7] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN7 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN7]) - GVL.w_InkInputIntMin[FTN7]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN7] - GVL.w_InkInputIntMin[FTN7]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterInput[FTN7] > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN7] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN7] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN7] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN7] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN7 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN7]) - GVL.w_InkInputIntMin[FTN7]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN7] - GVL.w_InkInputIntMin[FTN7]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterSweepOut[FTN7]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.WaterSweepOut[FTN7] < (w_output_incr * 10) THEN
					GVL_IO.WaterSweepOut[FTN7] := GVL_IO.WaterSweepOut[FTN7] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterSweepOut[FTN7] > w_output_incr THEN
					GVL_IO.WaterSweepOut[FTN7] := GVL_IO.WaterSweepOut[FTN7] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 18:CASE GVL.mb_Output_Registers[GVL.WATERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN8] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN8] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN8] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN8] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN8] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN8] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN8] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN8] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterInput[FTN8]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF GVL_IO.WaterInput[FTN8] < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN8] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN8] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN8] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN8] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN8 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN8]) - GVL.w_InkInputIntMin[FTN8]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN8] - GVL.w_InkInputIntMin[FTN8]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterInput[FTN8] > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN8] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN8] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN8] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN8] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN8 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN8]) - GVL.w_InkInputIntMin[FTN8]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN8] - GVL.w_InkInputIntMin[FTN8]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterSweepOut[FTN8]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.WaterSweepOut[FTN8] < (w_output_incr * 10) THEN
					GVL_IO.WaterSweepOut[FTN8] := GVL_IO.WaterSweepOut[FTN8] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterSweepOut[FTN8] > w_output_incr THEN
					GVL_IO.WaterSweepOut[FTN8] := GVL_IO.WaterSweepOut[FTN8] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 19:CASE GVL.mb_Output_Registers[GVL.WATERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN9] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN9] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN9] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN9] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN9] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN9] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN9] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN9] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterInput[FTN9]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF GVL_IO.WaterInput[FTN9] < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN9] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN9] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN9] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN9] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN9 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN9]) - GVL.w_InkInputIntMin[FTN9]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN9] - GVL.w_InkInputIntMin[FTN9]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterInput[FTN9] > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN9] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN9] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN9] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN9] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN9 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN9]) - GVL.w_InkInputIntMin[FTN9]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN9] - GVL.w_InkInputIntMin[FTN9]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterSweepOut[FTN9]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.WaterSweepOut[FTN9] < (w_output_incr * 10) THEN
					GVL_IO.WaterSweepOut[FTN9] := GVL_IO.WaterSweepOut[FTN9] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterSweepOut[FTN9] > w_output_incr THEN
					GVL_IO.WaterSweepOut[FTN9] := GVL_IO.WaterSweepOut[FTN9] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 20:CASE GVL.mb_Output_Registers[GVL.WATERHARDWARETYPE] OF
(* 		GVL.SWPWTR_TIME:
			//GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	0;	//nothing to read with FB circuit, just move motor
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN10] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN10] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN10] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN10] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF TRUE THEN							//test the FB for limit - can't do this, pass through
					GVL_IO.WaterMotorFwd[FTN10] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN10] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN10] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN10] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_FB:
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterInput[FTN10]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN		//move the motor forward
				IF GVL_IO.WaterInput[FTN10] < 32000 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN10] := TRUE;				// turn on the advance output
					GVL_IO.WaterMotorRvs[FTN10] := FALSE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN10] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN10] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN10 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN10]) - GVL.w_InkInputIntMin[FTN10]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN10] - GVL.w_InkInputIntMin[FTN10]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterInput[FTN10] > 800 THEN				//test the FB for limit - assumes 32767 is max of 10 VDC
					GVL_IO.WaterMotorFwd[FTN10] := FALSE;				// turn on the reverse output
					GVL_IO.WaterMotorRvs[FTN10] := TRUE;
					wCycleCount := wCycleCount + 1;
					IF wCycleCount > wMotorTimeOn THEN				//done with timer?
						GVL_IO.WaterMotorFwd[FTN10] := FALSE;		//turn off outputs
						GVL_IO.WaterMotorRvs[FTN10] := FALSE;
						GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
						wCycleCount := 0;					//reset the timer counter						
						//  curr % sweep   curr ticks - min tick allowed      max sweep %            max ticks allowed      min ticks allowed
						GVL.mb_Output_Registers[GVL.SWEEPTRIMONPRESS + (FTN10 * GVL.WORDRUNTIMEGROUPSIZE)]	:= (INT_TO_WORD(GVL_IO.InkInput[FTN10]) - GVL.w_InkInputIntMin[FTN10]) * 
								(GVL.mb_Output_Registers[GVL.MAXSWEEPTRIM]+1) / (GVL.w_InkInputIntMax[FTN10] - GVL.w_InkInputIntMin[FTN10]);
						//need the onpress setting pointed to the current % sweep of the positioner
					END_IF
				END_IF
			END_IF
		GVL.SWPWTR_OUTPUT:
			IF( GVL.b_DINTInput) THEN									//how big should the adv / ret control increment be?
				w_output_incr :=  DINT_TO_INT(GVL.d_DINT10V / 100);
			ELSE
				w_output_incr := (GVL.i_INT10V / 100);
			END_IF
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.WaterSweepOut[FTN10]);
			IF GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] THEN
				IF GVL_IO.WaterSweepOut[FTN10] < (w_output_incr * 10) THEN
					GVL_IO.WaterSweepOut[FTN10] := GVL_IO.WaterSweepOut[FTN10] + w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE;
			END_IF
			IF GVL.mb_Output_Coils[GVL.REALTIME_RETARD] THEN
				IF GVL_IO.WaterSweepOut[FTN10] > w_output_incr THEN
					GVL_IO.WaterSweepOut[FTN10] := GVL_IO.WaterSweepOut[FTN10] - w_output_incr;
				END_IF
				GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE;
			END_IF			
 *)
		GVL.SWPWTR_BRIDGE:
		END_CASE
	 21:   
(*		IF (GVL.b_DINTInput) THEN 
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	DINT_TO_WORD(GVL_IO.d_PressSpeed/(GVL.d_DINT10V/GVL.i_INT10V))*10;	//press speed (int type)
		ELSE
			GVL.mb_Output_Registers[GVL.REALTIME_PLC_A2D] :=	INT_TO_WORD(GVL_IO.i_PressSpeed);	//press speed (int type)
		END_IF
*)
		GVL.mb_Output_Coils[GVL.REALTIME_ADVANCE] := FALSE; // reset the advance boolean	- no adjustment possible here
		GVL.mb_Output_Coils[GVL.REALTIME_RETARD] := FALSE; // reset the reverse boolean
	 END_CASE
	 
	 
	  ]]></ST>
    </Implementation>
    <LineIds Name="FBRealtimeSupport">
      <LineId Id="9" Count="0" />
      <LineId Id="4" Count="4" />
      <LineId Id="1552" Count="0" />
      <LineId Id="10" Count="42" />
      <LineId Id="1610" Count="1" />
      <LineId Id="1609" Count="0" />
      <LineId Id="53" Count="34" />
      <LineId Id="1553" Count="0" />
      <LineId Id="89" Count="77" />
      <LineId Id="1554" Count="0" />
      <LineId Id="168" Count="77" />
      <LineId Id="1555" Count="0" />
      <LineId Id="247" Count="77" />
      <LineId Id="1556" Count="0" />
      <LineId Id="326" Count="77" />
      <LineId Id="1557" Count="0" />
      <LineId Id="405" Count="77" />
      <LineId Id="1558" Count="0" />
      <LineId Id="484" Count="77" />
      <LineId Id="1559" Count="0" />
      <LineId Id="563" Count="77" />
      <LineId Id="1560" Count="0" />
      <LineId Id="642" Count="43" />
      <LineId Id="1503" Count="0" />
      <LineId Id="686" Count="32" />
      <LineId Id="1561" Count="0" />
      <LineId Id="720" Count="357" />
      <LineId Id="1480" Count="0" />
      <LineId Id="1079" Count="377" />
      <LineId Id="2" Count="0" />
      <LineId Id="1459" Count="20" />
      <LineId Id="1527" Count="0" />
      <LineId Id="1481" Count="21" />
      <LineId Id="1528" Count="0" />
      <LineId Id="1504" Count="22" />
      <LineId Id="1529" Count="0" />
      <LineId Id="1531" Count="20" />
      <LineId Id="1787" Count="9" />
      <LineId Id="1562" Count="46" />
      <LineId Id="1797" Count="2" />
      <LineId Id="1612" Count="169" />
      <LineId Id="1851" Count="2" />
      <LineId Id="1855" Count="0" />
      <LineId Id="1854" Count="0" />
      <LineId Id="1782" Count="4" />
      <LineId Id="1800" Count="0" />
      <LineId Id="1856" Count="7" />
      <LineId Id="1801" Count="26" />
      <LineId Id="1902" Count="0" />
      <LineId Id="1828" Count="4" />
      <LineId Id="1864" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>